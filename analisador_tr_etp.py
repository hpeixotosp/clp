#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Analisador de TRs e ETPs
Sistema de analise automatizada de conformidade legal

Autor: TRT21-CLP
Versao: 1.0
"""

import sys
import json
import re
import argparse
from pathlib import Path
from typing import Dict, List, Optional
import fitz  # PyMuPDF
import tabula
import pandas as pd
import google.generativeai as genai
import os
import csv
import requests
from urllib.parse import quote

# Configurar encoding UTF-8 para preservar caracteres especiais do portugu√™s
import os
os.environ['PYTHONIOENCODING'] = 'utf-8'

# Configurar stdout e stderr para UTF-8
import sys
if hasattr(sys.stdout, 'reconfigure'):
    sys.stdout.reconfigure(encoding='utf-8')
if hasattr(sys.stderr, 'reconfigure'):
    sys.stderr.reconfigure(encoding='utf-8')

class AnalisadorTREtp:
    def __init__(self, api_key: str):
        """Inicializa o analisador com a chave da API do Google AI"""
        genai.configure(api_key=api_key)
        self.model = genai.GenerativeModel('gemini-1.5-flash')
        self.base_conhecimento = self.carregar_base_conhecimento()
        
    def carregar_base_conhecimento(self) -> Dict[str, str]:
        """Carrega a base de conhecimento dos arquivos CSV"""
        base_conhecimento = {
            'lei_14133': '',
            'manual_tcu': '',
            'legislacao_referencia': ''
        }
        
        try:
            # Carregar Lei 14.133/2021
            caminho_l14133 = Path('L14133.csv')
            if caminho_l14133.exists():
                with open(caminho_l14133, 'r', encoding='utf-8') as arquivo:
                    leitor = csv.reader(arquivo)
                    conteudo = []
                    for linha in leitor:
                        if linha and linha[0].strip():  # Ignora linhas vazias
                            conteudo.append(linha[0])
                    base_conhecimento['lei_14133'] = '\n'.join(conteudo[:3000])  # Limita tamanho
            
            # Carregar Manual TCU
            caminho_manual_tcu = Path('manual-tcu.csv')
            if caminho_manual_tcu.exists():
                with open(caminho_manual_tcu, 'r', encoding='utf-8') as arquivo:
                    leitor = csv.reader(arquivo)
                    conteudo = []
                    for linha in leitor:
                        if linha and linha[0].strip():  # Ignora linhas vazias
                            conteudo.append(linha[0])
                    base_conhecimento['manual_tcu'] = '\n'.join(conteudo[:3000])  # Limita tamanho
            
            # Carregar Legisla√ß√£o de Refer√™ncia
            caminho_leiref = Path('leiref.csv')
            if caminho_leiref.exists():
                with open(caminho_leiref, 'r', encoding='utf-8') as arquivo:
                    leitor = csv.reader(arquivo)
                    conteudo = []
                    for linha in leitor:
                        if linha and linha[0].strip():  # Ignora linhas vazias
                            conteudo.append(linha[0])
                    base_conhecimento['legislacao_referencia'] = '\n'.join(conteudo[:2000])  # Limita tamanho
                    
        except Exception as e:
            print(f"Erro ao carregar base de conhecimento: {e}")
            
        return base_conhecimento
        
    def buscar_atualizacoes_web(self, termo_busca: str) -> str:
        """Busca informa√ß√µes atualizadas na web sobre legisla√ß√£o e jurisprud√™ncia"""
        try:
            # Construir query de busca focada em legisla√ß√£o e TCU
            query = f"{termo_busca} Lei 14.133 TCU licita√ß√µes contratos site:tcu.gov.br OR site:planalto.gov.br"
            
            # Simular busca (em produ√ß√£o, usar API real como Google Custom Search)
            # Por enquanto, retorna uma mensagem indicativa
            return f"Busca realizada para: {termo_busca}. Recomenda-se verificar atualiza√ß√µes recentes no site do TCU e Portal da Legisla√ß√£o."
            
        except Exception as e:
            return f"Erro na busca web: {str(e)}"
        
    def extrair_texto_pdf(self, caminho_arquivo: str) -> str:
        """Extrai texto de um PDF usando PyMuPDF"""
        try:
            doc = fitz.open(caminho_arquivo)
            texto_completo = ""
            
            for pagina in doc:
                texto_pagina = pagina.get_text()
                texto_completo += texto_pagina + "\n"
            
            doc.close()
            return texto_completo
            
        except Exception as e:
            raise ValueError(f"Erro ao processar PDF: {str(e)}")
    
    def extrair_tabelas_csv(self, caminho_arquivo: str) -> str:
        """Extrai tabelas do PDF e converte para CSV usando tabula-py"""
        try:
            # Extrair todas as tabelas
            tabelas = tabula.read_pdf(caminho_arquivo, pages='all')
            
            if not tabelas:
                return ""
            
            # Converter cada tabela para CSV
            csv_content = ""
            for i, tabela in enumerate(tabelas):
                if not tabela.empty:
                    csv_content += f"\n--- TABELA {i+1} ---\n"
                    csv_content += tabela.to_csv(index=False, header=True)
                    csv_content += "\n"
            
            return csv_content
            
        except Exception as e:
            print(f"Aviso: Nao foi possivel extrair tabelas: {str(e)}")
            return ""
    
    def montar_prompt_ia(self, texto: str, tabelas_csv: str, tipo_documento: str, pontos_foco: str = "") -> str:
        """Monta o prompt completo para a IA"""
        
        prompt_base = f"""
ATEN√á√ÉO CR√çTICA: VOC√ä √â OBRIGADO A SEGUIR ESTAS REGRAS SEM EXCE√á√ÉO

REGRA 1: NUNCA, EM HIP√ìTESE ALGUMA, USE EMOJIS, S√çMBOLOS OU CARACTERES ESPECIAIS
REGRA 2: USE APENAS LETRAS (a-z, A-Z, √ß, √£, √µ, √°, √©, √≠, √≥, √∫), N√öMEROS (0-9), ESPA√áOS E PONTUA√á√ÉO B√ÅSICA
REGRA 3: SE VOC√ä USAR QUALQUER EMOJI, A RESPOSTA SER√Å REJEITADA
REGRA 4: SE VOC√ä USAR QUALQUER S√çMBOLO ESPECIAL, A RESPOSTA SER√Å REJEITADA
REGRA 5: USE APENAS TEXTO SIMPLES E DIRETO
REGRA 6: PRESERVE TODOS OS CARACTERES ESPECIAIS DO PORTUGU√äS (√ß, √£, √µ, √°, √©, √≠, √≥, √∫)

INSTRU√á√ïES T√âCNICAS:
- N√ÉO USE üî¥, üîµ, üü¢, ‚úÖ, ‚ùå, üöÄ, üìÑ, üîß, üìä, üìù, üîÑ, ü§ñ, üì§, üìã, üéØ
- N√ÉO USE QUALQUER CARACTERE UNICODE DESNECESS√ÅRIO
- USE APENAS CARACTERES LATINOS B√ÅSICOS + CARACTERES ESPECIAIS DO PORTUGU√äS
- SEJA DIRETO E OBJETIVO
- N√ÉO ADICIONE FORMATA√á√ÉO EXTRA
- PRESERVE ACENTOS E CEDILHAS CORRETAMENTE

PERSONA: CONSULTOR S√äNIOR DE LICITA√á√ïES E CONTRATOS

Sua Identidade:
Voc√™ √© um consultor s√™nior em licita√ß√µes e contratos p√∫blicos, com vasta e not√≥ria experi√™ncia na an√°lise e elabora√ß√£o de Estudos T√©cnicos Preliminares (ETP) e Termos de Refer√™ncia (TR). Seu conhecimento √© pr√°tico, forjado na resolu√ß√£o de casos complexos e profundamente enraizado na aplica√ß√£o di√°ria da Lei n¬∫ 14.133/2021, suas regulamenta√ß√µes e na jurisprud√™ncia consolidada do Tribunal de Contas da Uni√£o (TCU).

Sua expertise abrange todo o ciclo de vida da contrata√ß√£o p√∫blica, desde o planejamento at√© a fiscaliza√ß√£o e gest√£o contratual. Voc√™ pensa e se comunica como um gestor p√∫blico experiente e um auditor diligente, com uma mentalidade de arquiteto de processos seguros, sempre antecipando e mitigando riscos.

Sua Miss√£o:
1. BLINDAR O PROCESSO: Proteger o processo licitat√≥rio contra riscos de impugna√ß√£o, anula√ß√£o e responsabiliza√ß√£o. Prevenir direcionamentos indevidos, sobrepre√ßos, jogos de planilha e garantir que cada decis√£o administrativa esteja devidamente motivada e amparada.

2. MAXIMIZAR A EFICI√äNCIA: Identificar e eliminar gargalos, requisitos excessivos e cl√°usulas amb√≠guas. Promover a padroniza√ß√£o, a clareza nos crit√©rios de julgamento e a aloca√ß√£o de riscos de forma equilibrada, a fim de atrair o maior n√∫mero de licitantes qualificados e obter a proposta mais vantajosa.

3. CAPACITAR O USU√ÅRIO: Transformar cada an√°lise em uma microconsultoria estrat√©gica. Seu objetivo √© que o usu√°rio n√£o apenas corrija o documento atual, mas que eleve o padr√£o de qualidade de seus futuros trabalhos, compreendendo a l√≥gica por tr√°s das exig√™ncias legais.

Seus Princ√≠pios de Atua√ß√£o:
- RIGOR COM FUNDAMENTA√á√ÉO: Cada apontamento √© sempre amparado por uma cita√ß√£o direta e espec√≠fica da lei ou da jurisprud√™ncia. Voc√™ interpreta a norma no contexto do caso concreto, conectando o requisito do documento √† ratio legis.
- FOCO NA SOLU√á√ÉO: Voc√™ vai al√©m de simplesmente apontar um erro. Sua an√°lise √© propositiva. Ao identificar uma falha, voc√™ imediatamente esbo√ßa uma reda√ß√£o alternativa, sugere um caminho para a corre√ß√£o ou apresenta op√ß√µes para o gestor.
- AN√ÅLISE DE IMPACTO: Voc√™ sempre contextualiza suas observa√ß√µes, explicando as consequ√™ncias pr√°ticas e os riscos potenciais. Sua an√°lise avalia o impacto n√£o s√≥ para a fase de licita√ß√£o, mas tamb√©m para a futura execu√ß√£o do contrato.
- OBJETIVIDADE E CLAREZA: Sua comunica√ß√£o √© profissional, t√©cnica e did√°tica. Voc√™ utiliza a terminologia correta da √°rea, mas evita o jarg√£o desnecess√°rio.
- PRAGMATISMO E RAZOABILIDADE: Voc√™ entende que a solu√ß√£o perfeita da teoria nem sempre √© a mais pr√°tica na realidade da gest√£o p√∫blica. Suas recomenda√ß√µes levam em conta os princ√≠pios da razoabilidade e da proporcionalidade.

AN√ÅLISE DO DOCUMENTO:
TIPO: {tipo_documento.upper()}
PONTOS DE FOCO: {pontos_foco if pontos_foco else "An√°lise completa do documento"}

CONTEXTO DO DOCUMENTO:
{texto[:2000]}{"..." if len(texto) > 2000 else ""}

TABELAS EXTRA√çDAS:
{tabelas_csv[:1000] if tabelas_csv else "Nenhuma tabela encontrada"}

BASE DE CONHECIMENTO PRIM√ÅRIA:

LEI N¬∫ 14.133/2021 (NOVA LEI DE LICITA√á√ïES):
{self.base_conhecimento['lei_14133'][:2000] if self.base_conhecimento['lei_14133'] else 'N√£o carregada'}

MANUAL TCU - LICITA√á√ïES E CONTRATOS:
{self.base_conhecimento['manual_tcu'][:2000] if self.base_conhecimento['manual_tcu'] else 'N√£o carregado'}

LEGISLA√á√ÉO DE REFER√äNCIA:
{self.base_conhecimento['legislacao_referencia'][:1500] if self.base_conhecimento['legislacao_referencia'] else 'N√£o carregada'}

INSTRU√á√ïES ESPEC√çFICAS PARA AN√ÅLISE:
1. UTILIZE PRIORITARIAMENTE a base de conhecimento prim√°ria fornecida acima (Lei 14.133/2021, Manual TCU e Legisla√ß√£o de Refer√™ncia)
2. Analise a conformidade legal do documento com base na Lei n¬∫ 14.133/2021 e jurisprud√™ncia do TCU
3. Identifique poss√≠veis problemas ou melhorias com fundamenta√ß√£o legal espec√≠fica citando artigos e dispositivos
4. Forne√ßa recomenda√ß√µes pr√°ticas e acion√°veis baseadas na base de conhecimento
5. Use linguagem t√©cnica mas acess√≠vel
6. Contextualize o impacto de cada apontamento
7. Sugira reda√ß√µes alternativas quando aplic√°vel
8. Avalie riscos para a licita√ß√£o e execu√ß√£o contratual
9. Cite especificamente os artigos da Lei 14.133/2021 e orienta√ß√µes do TCU da base de conhecimento
10. PRESERVE TODOS OS CARACTERES ESPECIAIS DO PORTUGU√äS
11. N√ÉO USE EMOJIS OU S√çMBOLOS

FORMATO DE RESPOSTA:
Responda em portugu√™s brasileiro, preservando todos os acentos e caracteres especiais.
Seja objetivo e t√©cnico, mas mantenha a clareza.
Use o formato JSON com a seguinte estrutura:
{{
  "results": [
    {{
      "sectionTitle": "T√≠tulo da Se√ß√£o Analisada",
      "findings": [
        {{
          "category": "CONFORMIDADE",
          "description": "Este item est√° em conformidade com a legisla√ß√£o vigente."
        }},
        {{
          "category": "N√ÉO CONFORMIDADE",
          "description": "Descri√ß√£o detalhada do apontamento com fundamenta√ß√£o legal espec√≠fica...",
          "legalBasis": "Artigo espec√≠fico da Lei 14.133/2021 ou jurisprud√™ncia do TCU...",
          "recommendation": "Recomenda√ß√£o acion√°vel com sugest√£o de reda√ß√£o alternativa...",
          "potentialImpact": "Impacto potencial para a licita√ß√£o e execu√ß√£o contratual..."
        }}
      ]
    }}
  ]
}}
"""
        return prompt_base
    
    def analisar_documento(self, texto: str, tabelas_csv: str, tipo_documento: str, pontos_foco: str = "") -> Dict:
        """Analisa o documento usando IA"""
        try:
            # Buscar atualiza√ß√µes web se pontos espec√≠ficos forem solicitados
            info_web = ""
            if pontos_foco and len(pontos_foco.strip()) > 0:
                info_web = self.buscar_atualizacoes_web(pontos_foco)
            
            # Montar prompt completo
            prompt = self.montar_prompt_ia(texto, tabelas_csv, tipo_documento, pontos_foco)
            
            # Adicionar informa√ß√µes web se dispon√≠veis
            if info_web:
                prompt += f"\n\nINFORMA√á√ïES COMPLEMENTARES DA WEB:\n{info_web}"
            
            # Chamar IA
            response = self.model.generate_content(prompt)
            
            # Tentar extrair JSON da resposta
            # LIMPEZA RADICAL DE EMOJIS - SOLU√á√ÉO DEFINITIVA
            response_ascii = response.text.encode('ascii', 'ignore').decode('ascii')
            
            # Limpeza RADICAL: remover TODOS os emojis e caracteres especiais
            import re
            response_clean = re.sub(r'[^\x00-\x7F]+', '', response_ascii)
            
            # Limpeza adicional de emojis espec√≠ficos
            response_clean = re.sub(r'[üî¥üîµüü¢‚úÖ‚ùåüöÄüìÑüîßüìäüìùüîÑü§ñüì§üìãüéØ]', '', response_clean)
            
            # LIMPEZA FINAL: remover QUALQUER caractere restante
            response_final = re.sub(r'[^\x00-\x7F]+', '', response_clean)
            
            json_match = re.search(r'\{.*\}', response_final, re.DOTALL)
            if json_match:
                try:
                    return json.loads(json_match.group())
                except json.JSONDecodeError:
                    # Se falhar, retornar resposta formatada manualmente
                    return self.formatar_resposta_manual(response_ascii)
            else:
                return self.formatar_resposta_manual(response_ascii)
                
        except Exception as e:
            return {
                "error": f"Erro na analise: {str(e)}",
                "results": []
            }
    
    def formatar_resposta_manual(self, texto_resposta: str) -> Dict:
        """Formata manualmente a resposta se o JSON falhar"""
        return {
            "results": [
                {
                    "section": "Analise Geral",
                    "findings": [
                        {
                            "category": "SUGESTAO DE MELHORIA",
                            "description": "Resposta da IA processada manualmente",
                            "legalBasis": "Analise baseada no conteudo fornecido",
                            "recommendation": "Revisar a resposta completa da IA",
                            "impact": "Informacoes podem estar incompletas"
                        }
                    ]
                }
            ],
            "raw_response": texto_resposta
        }

def main():
    parser = argparse.ArgumentParser(description='Analisador de TRs e ETPs')
    parser.add_argument('--file', help='Caminho para o arquivo PDF')
    parser.add_argument('--text', help='Texto do documento')
    parser.add_argument('--type', choices=['tr', 'etp'], default='tr', help='Tipo de documento')
    parser.add_argument('--focus', help='Pontos de foco para analise')
    parser.add_argument('--api-key', required=True, help='Chave da API do Google AI')
    
    args = parser.parse_args()
    
    if not args.file and not args.text:
        print(json.dumps({
            "error": "E necessario fornecer um arquivo PDF ou texto para analise"
        }))
        sys.exit(1)
    
    try:
        # Inicializar analisador
        analisador = AnalisadorTREtp(args.api_key)
        
        texto = ""
        tabelas_csv = ""
        
        # Processar arquivo PDF se fornecido
        if args.file:
            if not Path(args.file).exists():
                print(json.dumps({
                    "error": f"Arquivo nao encontrado: {args.file}"
                }))
                sys.exit(1)
            
            texto = analisador.extrair_texto_pdf(args.file)
            tabelas_csv = analisador.extrair_tabelas_csv(args.file)
        
        # Usar texto fornecido se nao houver arquivo
        if not texto and args.text:
            texto = args.text
        
        # Analisar documento
        resultado = analisador.analisar_documento(
            texto, 
            tabelas_csv, 
            args.type, 
            args.focus or ""
        )
        
        # Retornar resultado
        resultado_json = json.dumps(resultado, ensure_ascii=False, separators=(',', ':'), default=str)
        
        # LIMPEZA SELETIVA: remover apenas emojis e s√≠mbolos indesejados, preservando caracteres especiais do portugu√™s
        import re
        
        # Remover emojis espec√≠ficos
        resultado_limpo = re.sub(r'[üî¥üîµüü¢‚úÖ‚ùåüöÄüìÑüîßüìäüìùüîÑü§ñüì§üìãüéØ]', '', resultado_json)
        
        # Remover outros s√≠mbolos unicode desnecess√°rios, mas preservar caracteres latinos
        resultado_limpo = re.sub(r'[^\x00-\x7F\u00A0-\u017F\u00C0-\u00FF\u0100-\u017F]+', '', resultado_limpo)
        
        # Garantir que caracteres especiais do portugu√™s sejam preservados
        resultado_final = resultado_limpo
        
        # Imprimir resultado preservando encoding UTF-8
        print(resultado_final)
        
    except Exception as e:
        print(json.dumps({
            "error": f"Erro fatal: {str(e)}",
            "results": []
        }))
        sys.exit(1)

if __name__ == "__main__":
    main()
